---
layout: default
---

{% include metadata.liquid %}
{% include header.html %}
{% assign index_bg = site.data.skin.index.bg  | default: 'gray-2' %}

<!-- <main class="my-4">
    <div class="container px-5 py-3 bg-{{ index_bg }} rounded">
        <h1 class="display-3">{{ site.title }}</h1>
        <p class="lead">{{ description }}</p>
        <hr class="my-4">
        {{ content }}
        {% if site.data.index.buttons %}
        <div class="btn-group-lg mt-4 mb-3" role="group">
            {% assign buttons = site.data.index.buttons %}
            {% for button in buttons %}
            {% assign classes = 'btn btn-primary d-block d-lg-inline-block my-lg-0' %}
            {% unless forloop.first or forloop.last %}
            {% assign classes = classes | append: ' my-2 mx-lg-2' %}
            {% endunless %}
            {% if button.disabled %}
            {% assign classes = classes | append: ' disabled' %}
            {% assign a = '' %}
            {% else %}
            {% assign a = 'href="' | append: button.url | append: '"' %}
            {% endif %}
            <a {{ a }} type="button" class="{{ classes }}" target="_blank">{{ button.text | upcase }}</a>
            {% endfor %}
        </div>
        {% endif %}
    </div>
</main>
 -->
<div>
    <canvas style="width: 1920px; height: 489px;"></canvas>
</div>
<main class="my-4 container">
    <div class="title-container">
        <div class="paralax-container">
            <div class="paralax"></div>
            <h1 class="title-s1">Information Systems</h1>
        </div>

        <div class="paralax-container" id="amp">
            <div class="paralax"></div>
            <h1 class="title-s2">&</h1>
        </div>

        <div class="paralax-container" id="databases">
            <div class="paralax"></div>
            <h1 class="title-s3">Databases</h1>
        </div>
        
    </div>
</main>
{% include footer.html %}
<script type="module">

    import * as THREE from 'three';

    // import Stats from 'three/addons/libs/stats.module.js';

    let container, stats;

    let camera, scene, renderer;

    let group;

    let targetRotation = 0;
    let targetRotationOnPointerDown = 0;

    let pointerX = 0;
    let pointerXOnPointerDown = 0;

    let windowHalfX = window.innerWidth / 2;

    init();

    function init() {

        container = document.getElementById( 'animationBG' );
        // document.body.appendChild( container );

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xffffff );

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set( 0, 150, 500 );
        scene.add( camera );

        const light = new THREE.PointLight( 0xffffff, 2.5, 0, 0 );
        camera.add( light );

        group = new THREE.Group();
        group.position.y = 300;
        group.position.x = 100;
        group.position.z = 10;
        scene.add( group );

        // the following lines are for adding texture in the shape
        // ---------start of lines--------------------
        // const loader = new THREE.TextureLoader();
        // const texture = loader.load( 'textures/uv_grid_opengl.jpg' );
        // texture.colorSpace = THREE.SRGBColorSpace;
        // // it's necessary to apply these settings in order to correctly display the texture on a shape geometry
        // texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        // texture.repeat.set( 0.008, 0.008 );
        // ---------end of lines---------------------

        function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s, flip ) {

            // flat shape with texture
            // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

            let geometry = new THREE.ShapeGeometry( shape );
            let mesh;

            // let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } ) );
            // mesh.position.set( x, y, z - 175 );
            // mesh.rotation.set( rx, ry, rz );
            // mesh.scale.set( s, s, s );
            // group.add( mesh );

            // flat shape

            // geometry = new THREE.ShapeGeometry( shape );

            // mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );
            // mesh.position.set( x, y, z - 125 );
            // mesh.rotation.set( rx, ry, rz );
            // mesh.scale.set( s, s, s );
            // group.add( mesh );

            // extruded shape

            geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

            mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color } ) );
            mesh.position.set( x, y, z - 75 );
            mesh.rotation.set( rx, ry, rz );
            mesh.scale.set( s, s, s );
            group.add( mesh );
            if (flip == 1) {
                mesh.scale.x = -1;
            }

            addLineShape( shape, color, x, y, z, rx, ry, rz, s, flip );

        }

        function addLineShape( shape, color, x, y, z, rx, ry, rz, s, flip ) {

            // lines

            shape.autoClose = true;

            const points = shape.getPoints();
            const spacedPoints = shape.getSpacedPoints( 50 );

            const geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
            const geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints( spacedPoints );

            // solid line

            let line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );
            line.position.set( x, y, z - 25 );
            line.rotation.set( rx, ry, rz );
            line.scale.set( s, s, s );
            group.add( line );

            // line from equidistance sampled points

            // line = new THREE.Line( geometrySpacedPoints, new THREE.LineBasicMaterial( { color: color } ) );
            // line.position.set( x, y, z + 25 );
            // line.rotation.set( rx, ry, rz );
            // line.scale.set( s, s, s );
            // group.add( line );

            // vertices from real points

            let particles = new THREE.Points( geometryPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
            // particles.position.set( x, y, z + 75 );
            // particles.rotation.set( rx, ry, rz );
            // particles.scale.set( s, s, s );
            // group.add( particles );

            // equidistance sampled points

            particles = new THREE.Points( geometrySpacedPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
            particles.position.set( x, y, z  );
            particles.rotation.set( rx, ry, rz );
            particles.scale.set( s, s, s );
            group.add( particles );
            if (flip == 1) {
                particles.scale.x = -1;
                line.scale.x = -1;
            }

        }


        // California

        const californiaPts = [];

        californiaPts.push( new THREE.Vector2( 610, 320 ) );
        californiaPts.push( new THREE.Vector2( 450, 300 ) );
        californiaPts.push( new THREE.Vector2( 392, 392 ) );
        californiaPts.push( new THREE.Vector2( 266, 438 ) );
        californiaPts.push( new THREE.Vector2( 190, 570 ) );
        californiaPts.push( new THREE.Vector2( 190, 600 ) );
        californiaPts.push( new THREE.Vector2( 160, 620 ) );
        californiaPts.push( new THREE.Vector2( 160, 650 ) );
        californiaPts.push( new THREE.Vector2( 180, 640 ) );
        californiaPts.push( new THREE.Vector2( 165, 680 ) );
        californiaPts.push( new THREE.Vector2( 150, 670 ) );
        californiaPts.push( new THREE.Vector2( 90, 737 ) );
        californiaPts.push( new THREE.Vector2( 80, 795 ) );
        californiaPts.push( new THREE.Vector2( 50, 835 ) );
        californiaPts.push( new THREE.Vector2( 64, 870 ) );
        californiaPts.push( new THREE.Vector2( 60, 945 ) );
        californiaPts.push( new THREE.Vector2( 300, 945 ) );
        californiaPts.push( new THREE.Vector2( 300, 743 ) );
        californiaPts.push( new THREE.Vector2( 600, 473 ) );
        californiaPts.push( new THREE.Vector2( 626, 425 ) );
        californiaPts.push( new THREE.Vector2( 600, 370 ) );
        californiaPts.push( new THREE.Vector2( 610, 320 ) );

        for ( let i = 0; i < californiaPts.length; i ++ ) californiaPts[ i ].multiplyScalar( 0.25 );

        const californiaShape = new THREE.Shape( californiaPts );


        let points = [];
        // the <
        points.push(new THREE.Vector2(20, 0));
        points.push(new THREE.Vector2(65, -35));
        points.push(new THREE.Vector2(65, -50));
        points.push(new THREE.Vector2(0, -5));
        points.push(new THREE.Vector2(0, 5));
        points.push(new THREE.Vector2(65, 50));
        points.push(new THREE.Vector2(65, 35));
        const shape1 = new THREE.Shape( points );


        // the /
        points = []
        points.push(new THREE.Vector2(20, 70));
        points.push(new THREE.Vector2(-20, -70));
        points.push(new THREE.Vector2(-10, -70));
        points.push(new THREE.Vector2(30, 70));
        const shape2 = new THREE.Shape( points )

        // the >

        
        const shape3 = shape1.clone()

        const symbol = new THREE.BufferGeometry();

        

        const extrudeSettings = { depth: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

        // addShape( californiaShape, extrudeSettings, 0xf08000, 200, -100, 100, 0, 0, 0, 1, 0 );
        addShape( shape1, extrudeSettings, 0xf08000, -150, 50, 100, 0, 0, 0, 1, 0 );
        addShape( shape2, extrudeSettings, 0xf08000, -60, 50, 100, 0, 0, 0, 1, 0 ); 
        addShape( shape3, extrudeSettings, 0xf08000, 40, 50, 100, 0, 0, 0, 1, 1 ); 
        

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setAnimationLoop( animate );
        container.appendChild( renderer.domElement );

        container.style.touchAction = 'none';
        container.addEventListener( 'pointerdown', onPointerDown );

        window.addEventListener( 'resize', onWindowResize );

    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function onPointerDown( event ) {

        if ( event.isPrimary === false ) return;

        pointerXOnPointerDown = event.clientX - windowHalfX;
        targetRotationOnPointerDown = targetRotation;

        document.addEventListener( 'pointermove', onPointerMove );
        document.addEventListener( 'pointerup', onPointerUp );

    }

    function onPointerMove( event ) {

        if ( event.isPrimary === false ) return;

        pointerX = event.clientX - windowHalfX;

        targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

    }

    function onPointerUp() {

        if ( event.isPrimary === false ) return;

        document.removeEventListener( 'pointermove', onPointerMove );
        document.removeEventListener( 'pointerup', onPointerUp );

    }


    function animate() {
        render();
    }

    function render() {
        group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
        renderer.render( scene, camera );

    }

</script>