---
layout: default
---

{% include metadata.liquid %}
{% include header.html %}
{% assign index_bg = site.data.skin.index.bg  | default: 'gray-2' %}

<!-- <main class="my-4">
    <div class="container px-5 py-3 bg-{{ index_bg }} rounded">
        <h1 class="display-3">{{ site.title }}</h1>
        <p class="lead">{{ description }}</p>
        <hr class="my-4">
        {{ content }}
        {% if site.data.index.buttons %}
        <div class="btn-group-lg mt-4 mb-3" role="group">
            {% assign buttons = site.data.index.buttons %}
            {% for button in buttons %}
            {% assign classes = 'btn btn-primary d-block d-lg-inline-block my-lg-0' %}
            {% unless forloop.first or forloop.last %}
            {% assign classes = classes | append: ' my-2 mx-lg-2' %}
            {% endunless %}
            {% if button.disabled %}
            {% assign classes = classes | append: ' disabled' %}
            {% assign a = '' %}
            {% else %}
            {% assign a = 'href="' | append: button.url | append: '"' %}
            {% endif %}
            <a {{ a }} type="button" class="{{ classes }}" target="_blank">{{ button.text | upcase }}</a>
            {% endfor %}
        </div>
        {% endif %}
    </div>
</main>
 -->

<div class="homepage-container"></div>
    <main class="my-4 homepage-content">
        <div id="animationBG">
        </div>
        <div class="title-container">
            <div class="paralax-container">
                <div class="paralax"></div>
                <h1 class="title-s1">Information Systems</h1>
            </div>
    
            <div class="paralax-container" id="amp">
                <div class="paralax"></div>
                <h1 class="title-s2">&</h1>
            </div>
    
            <div class="paralax-container" id="databases">
                <div class="paralax"></div>
                <h1 class="title-s3">Databases</h1>
            </div>
            
        </div>
    </main>
</div>
{% include footer.html %}
<script type="module">

    import * as THREE from 'three';


    let group;
    let container, stats;
    const particlesData = [];
    let camera, scene, renderer;
    let positions, colors;
    let particles;
    let pointCloud;
    let particlePositions;
    let linesMesh;

    const maxParticleCount = 1000;
    let particleCount = 1000;
    const r = 2000; // the dimansion that the particles will take
    const rHalf = r / 2;

    const effectController = {
        showDots: true,
        showLines: true,
        minDistance: 150,
        limitConnections: false,
        maxConnections: 1000,
        particleCount: 500
    };

    init();

    function init() {

        container = document.getElementById( 'animationBG' );


        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );
        camera.position.z = 1750;

        scene = new THREE.Scene();

        scene.background = new THREE.Color( 0xffffff );


        group = new THREE.Group();
        scene.add( group );

        // draw the box that contains the patricles
        // const helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r ) ) );
        // helper.material.color.setHex( 0x474747 );
        // helper.material.blending = THREE.AdditiveBlending;
        // helper.material.transparent = true;
        // group.add( helper );

        const segments = maxParticleCount * maxParticleCount;

        positions = new Float32Array( segments * 3 );
        colors = new Float32Array( segments * 3 );

        const pMaterial = new THREE.PointsMaterial( {
            color: 0x1b4377,
            size: 3,
            blending: THREE.CustomBlending,
            transparent: false,
            sizeAttenuation: false
        } );

        particles = new THREE.BufferGeometry();
        particlePositions = new Float32Array( maxParticleCount * 3 );

        for ( let i = 0; i < maxParticleCount; i ++ ) {

            const x = Math.random() * r - r / 2;
            const y = Math.random() * r - r / 2;
            const z = Math.random() * r - r / 2;

            particlePositions[ i * 3 ] = x;
            particlePositions[ i * 3 + 1 ] = y;
            particlePositions[ i * 3 + 2 ] = z;

            // add it to the geometry
            particlesData.push( {
                velocity: new THREE.Vector3( - 1 + Math.random() * 2, - 1 + Math.random() * 2, - 1 + Math.random() * 2 ),
                numConnections: 0
            } );

        }

        particles.setDrawRange( 0, particleCount );
        particles.setAttribute( 'position', new THREE.BufferAttribute( particlePositions, 3 ).setUsage( THREE.DynamicDrawUsage ) );

        // create the particle system
        pointCloud = new THREE.Points( particles, pMaterial );
        group.add( pointCloud );

        const geometry = new THREE.BufferGeometry();

        geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setUsage( THREE.DynamicDrawUsage ) );
        geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).setUsage( THREE.DynamicDrawUsage ) );

        geometry.computeBoundingSphere();

        geometry.setDrawRange( 0, 0 );

        const material = new THREE.LineBasicMaterial( {
            color: 0x1b4377,
            vertexColors: true,
            blending: THREE.CustomBlending,
            transparent: true
        } );

        linesMesh = new THREE.LineSegments( geometry, material );
        group.add( linesMesh );

        //

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setAnimationLoop( animate );
        container.appendChild( renderer.domElement );


        window.addEventListener( 'resize', onWindowResize );

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {

        let vertexpos = 0;
        let colorpos = 0;
        let numConnected = 0;

        for ( let i = 0; i < particleCount; i ++ )
            particlesData[ i ].numConnections = 0;

        for ( let i = 0; i < particleCount; i ++ ) {

            // get the particle
            const particleData = particlesData[ i ];

            // get the particles moving
            particlePositions[ i * 3 ] += particleData.velocity.x;
            particlePositions[ i * 3 + 1 ] += particleData.velocity.y;
            particlePositions[ i * 3 + 2 ] += particleData.velocity.z;

            if ( particlePositions[ i * 3 + 1 ] < - rHalf || particlePositions[ i * 3 + 1 ] > rHalf )
                particleData.velocity.y = - particleData.velocity.y;

            if ( particlePositions[ i * 3 ] < - rHalf || particlePositions[ i * 3 ] > rHalf )
                particleData.velocity.x = - particleData.velocity.x;

            if ( particlePositions[ i * 3 + 2 ] < - rHalf || particlePositions[ i * 3 + 2 ] > rHalf )
                particleData.velocity.z = - particleData.velocity.z;

            if ( effectController.limitConnections && particleData.numConnections >= effectController.maxConnections )
                continue;

            // Check collision
            for ( let j = i + 1; j < particleCount; j ++ ) {

                const particleDataB = particlesData[ j ];
                if ( effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections )
                    continue;

                const dx = particlePositions[ i * 3 ] - particlePositions[ j * 3 ];
                const dy = particlePositions[ i * 3 + 1 ] - particlePositions[ j * 3 + 1 ];
                const dz = particlePositions[ i * 3 + 2 ] - particlePositions[ j * 3 + 2 ];
                const dist = Math.sqrt( dx * dx + dy * dy + dz * dz );

                if ( dist < effectController.minDistance ) {

                    particleData.numConnections ++;
                    particleDataB.numConnections ++;

                    const alpha = 1.0 - dist / effectController.minDistance;

                    positions[ vertexpos ++ ] = particlePositions[ i * 3 ];
                    positions[ vertexpos ++ ] = particlePositions[ i * 3 + 1 ];
                    positions[ vertexpos ++ ] = particlePositions[ i * 3 + 2 ];

                    positions[ vertexpos ++ ] = particlePositions[ j * 3 ];
                    positions[ vertexpos ++ ] = particlePositions[ j * 3 + 1 ];
                    positions[ vertexpos ++ ] = particlePositions[ j * 3 + 2 ];

                    colors[ colorpos ++ ] = alpha;
                    colors[ colorpos ++ ] = alpha;
                    colors[ colorpos ++ ] = alpha;

                    colors[ colorpos ++ ] = alpha;
                    colors[ colorpos ++ ] = alpha;
                    colors[ colorpos ++ ] = alpha;

                    numConnected ++;

                }

            }

        }


        linesMesh.geometry.setDrawRange( 0, numConnected * 2 );
        linesMesh.geometry.attributes.position.needsUpdate = true;
        linesMesh.geometry.attributes.color.needsUpdate = true;

        pointCloud.geometry.attributes.position.needsUpdate = true;

        render();

    }

    function render() {

        const time = Date.now() * 0.001;

        group.rotation.z = time * 0.1;
        group.rotation.y = time * 0.01;
        renderer.render( scene, camera );

    }

</script>