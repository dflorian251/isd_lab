<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title></title>
		<link rel="stylesheet" href="./assets/css/styles.css">

		<script type="importmap">
			{
			"imports": {
				"three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.164.1/three.module.js"
			}
			}
		</script>

		
		<script type="module" src="../../chart.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2"></script>
	</head>
	
	<body>
		<header class="bg-{{ site.data.skin.header.bg | default: 'gray-4' }}">
			<div class="container">
				<nav class="navbar navbar-expand-sm">
					<a class="navbar-brand" href="{{ site.url }}">
					  <img class="navbar-logo" src="/assets/images/logo.png">
					</a>
					<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navigation" aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
						<span class="navbar-toggler-icon"></span>
					</button>
					<div class="collapse navbar-collapse" id="navigation">
						<div class="navbar-nav">
							<a class="nav-link active" aria-current="page" href="{{ href }}">link</a>
							<a class="nav-link" href="{{ href }}"></a>
						</div>
					</div>
				</nav>
			</div>
		</header>
		<main class="my-4 container">
			<div class="title-container">
				<div class="paralax-container">
					<div class="paralax"></div>
					<h1 class="title-s1">Information Systems</h1>
				</div>

				<div class="paralax-container" id="amp">
					<div class="paralax"></div>
					<h1 class="title-s2">&</h1>
				</div>

				<div class="paralax-container" id="databases">
					<div class="paralax"></div>
					<h1 class="title-s3">Databases</h1>
				</div>
				
			</div>
		</main>
		<script type="module">

			import * as THREE from 'three';

			// import Stats from 'three/addons/libs/stats.module.js';

			let container, stats;

			let camera, scene, renderer;

			let group;

			let targetRotation = 0;
			let targetRotationOnPointerDown = 0;

			let pointerX = 0;
			let pointerXOnPointerDown = 0;

			let windowHalfX = window.innerWidth / 2;

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 150, 500 );
				scene.add( camera );

				const light = new THREE.PointLight( 0xffffff, 2.5, 0, 0 );
				camera.add( light );

				group = new THREE.Group();
				group.position.y = 50;
				scene.add( group );

				// the following lines are for adding texture in the shape
				// ---------start of lines--------------------
				// const loader = new THREE.TextureLoader();
				// const texture = loader.load( 'textures/uv_grid_opengl.jpg' );
				// texture.colorSpace = THREE.SRGBColorSpace;
				// // it's necessary to apply these settings in order to correctly display the texture on a shape geometry
				// texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				// texture.repeat.set( 0.008, 0.008 );
				// ---------end of lines---------------------

				function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s, flip ) {

					// flat shape with texture
					// note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

					let geometry = new THREE.ShapeGeometry( shape );
					let mesh;

					// let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } ) );
					// mesh.position.set( x, y, z - 175 );
					// mesh.rotation.set( rx, ry, rz );
					// mesh.scale.set( s, s, s );
					// group.add( mesh );

					// flat shape

					// geometry = new THREE.ShapeGeometry( shape );

					// mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );
					// mesh.position.set( x, y, z - 125 );
					// mesh.rotation.set( rx, ry, rz );
					// mesh.scale.set( s, s, s );
					// group.add( mesh );

					// extruded shape

					geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

					mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color } ) );
					mesh.position.set( x, y, z - 75 );
					mesh.rotation.set( rx, ry, rz );
					mesh.scale.set( s, s, s );
					group.add( mesh );
					if (flip == 1) {
						mesh.scale.x = -1;
					}

					addLineShape( shape, color, x, y, z, rx, ry, rz, s, flip );

				}

				function addLineShape( shape, color, x, y, z, rx, ry, rz, s, flip ) {

					// lines

					shape.autoClose = true;

					const points = shape.getPoints();
					const spacedPoints = shape.getSpacedPoints( 50 );

					const geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
					const geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints( spacedPoints );

					// solid line

					let line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );
					line.position.set( x, y, z - 25 );
					line.rotation.set( rx, ry, rz );
					line.scale.set( s, s, s );
					group.add( line );

					// line from equidistance sampled points

					// line = new THREE.Line( geometrySpacedPoints, new THREE.LineBasicMaterial( { color: color } ) );
					// line.position.set( x, y, z + 25 );
					// line.rotation.set( rx, ry, rz );
					// line.scale.set( s, s, s );
					// group.add( line );

					// vertices from real points

					let particles = new THREE.Points( geometryPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
					// particles.position.set( x, y, z + 75 );
					// particles.rotation.set( rx, ry, rz );
					// particles.scale.set( s, s, s );
					// group.add( particles );

					// equidistance sampled points

					particles = new THREE.Points( geometrySpacedPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
					particles.position.set( x, y, z  );
					particles.rotation.set( rx, ry, rz );
					particles.scale.set( s, s, s );
					group.add( particles );
					if (flip == 1) {
						particles.scale.x = -1;
						line.scale.x = -1;
					}

				}


				// California

				const californiaPts = [];

				californiaPts.push( new THREE.Vector2( 610, 320 ) );
				californiaPts.push( new THREE.Vector2( 450, 300 ) );
				californiaPts.push( new THREE.Vector2( 392, 392 ) );
				californiaPts.push( new THREE.Vector2( 266, 438 ) );
				californiaPts.push( new THREE.Vector2( 190, 570 ) );
				californiaPts.push( new THREE.Vector2( 190, 600 ) );
				californiaPts.push( new THREE.Vector2( 160, 620 ) );
				californiaPts.push( new THREE.Vector2( 160, 650 ) );
				californiaPts.push( new THREE.Vector2( 180, 640 ) );
				californiaPts.push( new THREE.Vector2( 165, 680 ) );
				californiaPts.push( new THREE.Vector2( 150, 670 ) );
				californiaPts.push( new THREE.Vector2( 90, 737 ) );
				californiaPts.push( new THREE.Vector2( 80, 795 ) );
				californiaPts.push( new THREE.Vector2( 50, 835 ) );
				californiaPts.push( new THREE.Vector2( 64, 870 ) );
				californiaPts.push( new THREE.Vector2( 60, 945 ) );
				californiaPts.push( new THREE.Vector2( 300, 945 ) );
				californiaPts.push( new THREE.Vector2( 300, 743 ) );
				californiaPts.push( new THREE.Vector2( 600, 473 ) );
				californiaPts.push( new THREE.Vector2( 626, 425 ) );
				californiaPts.push( new THREE.Vector2( 600, 370 ) );
				californiaPts.push( new THREE.Vector2( 610, 320 ) );

				for ( let i = 0; i < californiaPts.length; i ++ ) californiaPts[ i ].multiplyScalar( 0.25 );

				const californiaShape = new THREE.Shape( californiaPts );

	
				let points = [];
				// the <
				points.push(new THREE.Vector2(20, 0));
				points.push(new THREE.Vector2(65, -35));
				points.push(new THREE.Vector2(65, -50));
				points.push(new THREE.Vector2(0, -5));
				points.push(new THREE.Vector2(0, 5));
				points.push(new THREE.Vector2(65, 50));
				points.push(new THREE.Vector2(65, 35));
				const shape1 = new THREE.Shape( points );


				// the /
				points = []
				points.push(new THREE.Vector2(20, 70));
				points.push(new THREE.Vector2(-20, -70));
				points.push(new THREE.Vector2(-10, -70));
				points.push(new THREE.Vector2(30, 70));
				const shape2 = new THREE.Shape( points )

				// the >

				
				const shape3 = shape1.clone()
 
				const symbol = new THREE.BufferGeometry();

				

				const extrudeSettings = { depth: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

				addShape( californiaShape, extrudeSettings, 0xf08000, 200, -100, 100, 0, 0, 0, 1, 0 );
				addShape( shape1, extrudeSettings, 0xf08000, -150, 50, 100, 0, 0, 0, 1, 0 );
				addShape( shape2, extrudeSettings, 0xf08000, -60, 50, 100, 0, 0, 0, 1, 0 ); 
				addShape( shape3, extrudeSettings, 0xf08000, 40, 50, 100, 0, 0, 0, 1, 1 ); 
				

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				container.style.touchAction = 'none';
				container.addEventListener( 'pointerdown', onPointerDown );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function onPointerDown( event ) {

				if ( event.isPrimary === false ) return;

				pointerXOnPointerDown = event.clientX - windowHalfX;
				targetRotationOnPointerDown = targetRotation;

				document.addEventListener( 'pointermove', onPointerMove );
				document.addEventListener( 'pointerup', onPointerUp );

			}

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				pointerX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

			}

			function onPointerUp() {

				if ( event.isPrimary === false ) return;

				document.removeEventListener( 'pointermove', onPointerMove );
				document.removeEventListener( 'pointerup', onPointerUp );

			}


			function animate() {
				render();
			}

			function render() {
				group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
